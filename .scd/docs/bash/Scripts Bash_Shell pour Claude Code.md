

# **Architecturer les Workflows Agentiques : Guide Complet sur le Scripting Shell dans l'Écosystème Anthropic Claude Code**

## **Introduction**

L'émergence de Claude Code d'Anthropic marque une évolution significative, transformant l'intelligence artificielle conversationnelle en un partenaire de développement agentique.1 Ce changement de paradigme déplace l'interaction d'un simple dialogue de questions-réponses vers une collaboration active où l'IA peut exécuter des tâches, manipuler des fichiers et interagir directement avec l'environnement de développement. La clé pour libérer tout le potentiel de ce modèle réside dans la maîtrise de son intégration profonde avec l'environnement natif du développeur : le shell.  
Une utilisation efficace de Claude Code ne se limite pas à la formulation de prompts ingénieux ; elle relève de l'architecture de workflows automatisés. Cela implique une utilisation délibérée et stratégique de ses composants fondamentaux : l'outil Bash, les commandes slash (slash commands), les hooks et les sous-agents (sub-agents).1 Ce rapport se présente comme un guide technique définitif, destiné aux développeurs et aux architectes logiciels qui cherchent à construire des systèmes agentiques robustes, sécurisés et évolutifs. Il explore les mécanismes de l'outil Bash, détaille la conception architecturale des composants d'automatisation, et établit des pratiques d'excellence avancées pour le scripting centré sur l'IA et la sécurité.  
---

## **Section 1 : L'outil Bash comme Primitive Fondamentale**

Cette section déconstruit l'outil Bash, le positionnant comme l'interface principale entre les capacités de raisonnement de Claude et le système de fichiers de l'utilisateur. Une compréhension approfondie de ses mécanismes est un prérequis essentiel pour toutes les stratégies d'automatisation ultérieures.

### **1.1 La Session Persistante : État et Environnement**

L'outil Bash de Claude Code ne se contente pas d'exécuter des commandes de manière isolée. Il opère au sein d'une session persistante qui maintient son état tout au long d'une conversation, incluant les variables d'environnement et le répertoire de travail courant.6 De plus, Claude Code hérite de l'environnement shell de l'utilisateur, lui donnant accès à tous les outils en ligne de commande familiers tels que git, npm, ou l'interface de ligne de commande de GitHub (gh).3 Cette persistance est une caractéristique essentielle qui élève l'outil Bash d'un simple exécuteur de commandes à un environnement d'exécution avec état. Elle permet à Claude de réaliser des opérations complexes en plusieurs étapes qui dépendent des actions précédentes, comme définir une variable d'environnement pour l'utiliser dans une commande ultérieure, ou naviguer dans une arborescence de répertoires (cd) avant d'opérer sur des fichiers spécifiques.6 Cette session est toutefois limitée à la conversation en cours et son état est perdu entre les différents appels à l'API.6  
Cette capacité transforme fondamentalement la manière dont l'agent interagit avec le code. Les modèles de langage sont intrinsèquement limités par la taille de leur fenêtre de contexte. Cependant, en utilisant des commandes Bash comme grep, tail ou find, Claude peut lire sélectivement des portions de fichiers volumineux ou effectuer des recherches dans l'ensemble d'un projet sans avoir à charger l'intégralité des données dans sa mémoire active.1 Le système de fichiers devient ainsi une extension de la fenêtre de contexte de l'IA, une sorte de mémoire externe vaste et interrogeable. Cette approche, où les données pertinentes sont chargées "juste à temps", est une forme de "context engineering" où la structure même des dossiers et des fichiers devient un élément stratégique pour guider l'agent.1

### **1.2 La Boucle de Débogage Agentique : Interprétation des Sorties de Commande**

Claude Code est conçu pour fonctionner de manière itérative. Il peut exécuter un script, interpréter ses sorties standard (stdout) et d'erreur (stderr), analyser son code de sortie, puis modifier le script jusqu'à l'obtention du résultat souhaité.3 Ce processus crée ce que l'on peut appeler la "boucle de débogage agentique la plus courte", offrant un retour d'information instantané qui permet à l'agent d'apprendre et de s'adapter.3 Le système est capable de gérer divers scénarios d'erreur, tels que les délais d'exécution dépassés, les commandes introuvables ou les permissions refusées, en recevant un tool\_result avec l'indicateur is\_error positionné à true.6  
Cette capacité est au cœur de la nature agentique de Claude. Il n'exécute pas les commandes aveuglément ; il observe les résultats et les utilise comme un signal pour informer sa prochaine action. Cette boucle—*agir, observer, corriger*—est fondamentale pour sa capacité à résoudre des problèmes de manière autonome. Cependant, ce mécanisme repose sur une interprétation littérale des conventions du shell. Une sortie ambiguë, des codes de sortie non standards, ou une verbosité excessive peuvent confondre l'agent, l'orientant vers des solutions incorrectes ou provoquant l'arrêt prématuré de son travail. Cela impose une nouvelle norme de scripting "consommable par l'IA", où la clarté, la concision et la gestion explicite des codes de sortie sont primordiales pour une collaboration homme-machine efficace.

### **1.3 Capacités et Contraintes Actuelles**

L'outil Bash excelle dans l'exécution de commandes non interactives, qu'elles soient sans état ou avec un état maintenu au sein de la session (ls, grep, cat, npm install, git commit).6 Sa principale limitation actuelle est son incapacité à gérer les commandes qui nécessitent une interaction en temps réel de l'utilisateur ou qui lancent une session interactive, comme vim, git rebase \-i, ou un REPL comme python.6 Cette contrainte oblige les utilisateurs à interrompre leur flux de travail dans Claude Code pour basculer vers un terminal distinct afin d'exécuter ces tâches.  
Cette absence d'interactivité définit une frontière claire pour les types de tâches entièrement automatisables. Les workflows qui exigent une édition interactive ou des prises de décision en cours de commande doivent être architecturés en tenant compte de cette limite. Une solution de contournement consiste à demander à Claude de préparer la commande, puis de donner l'instruction à l'utilisateur de l'exécuter manuellement. Une proposition d'amélioration technique, visible dans les discussions de la communauté, suggère d'intégrer un pseudo-terminal (PTY) pour prendre en charge ces sessions interactives directement au sein de Claude Code, ce qui indique une orientation claire pour le développement futur de l'outil.9  
---

## **Section 2 : Concevoir l'Automatisation avec les Composants Architecturaux de Claude Code**

Cette section propose une analyse comparative des trois principaux mécanismes d'intégration des scripts shell—les commandes slash, les hooks et les sous-agents—et établit un cadre de décision pour choisir l'outil approprié à chaque tâche.

### **2.1 Automatisation Initiée par l'Utilisateur via les Commandes Slash Personnalisées**

Les commandes slash personnalisées sont des modèles de prompts réutilisables, initiés par l'utilisateur, et définis dans des fichiers Markdown. Ces fichiers sont stockés soit au niveau du projet (.claude/commands/), soit au niveau de l'utilisateur (\~/.claude/commands/).3 Ils peuvent exécuter des commandes shell dont la sortie est injectée dans le contexte du prompt en préfixant la commande du caractère \!.3 Pour des raisons de sécurité, l'exécution de ces commandes nécessite une autorisation explicite via le champ allowed-tools dans l'en-tête (frontmatter) du fichier de commande.5 Les commandes slash prennent en charge le contenu dynamique grâce à des arguments ($ARGUMENTS, $1, etc.) et des références de fichiers (@).10  
Les commandes slash sont le mécanisme idéal pour encapsuler des workflows fréquents et en plusieurs étapes, mais qui restent déclenchés manuellement. Elles agissent comme des alias puissants et conscients du contexte. Par exemple, une commande /deploy peut être créée pour exécuter git status, npm run test, et npm run build, injectant les résultats directement dans le prompt pour donner à Claude un contexte complet avant qu'il ne procède au déploiement.10 Leur caractéristique clé est qu'elles sont *pilotées par l'utilisateur* ; elles simplifient la complexité mais n'initient pas d'actions de manière autonome.

### **2.2 Automatisation Déterministe et Événementielle avec les Hooks**

Les hooks sont des commandes shell qui s'exécutent automatiquement en réponse à des événements spécifiques du cycle de vie de l'agent, tels que PreToolUse (avant l'utilisation d'un outil), PostToolUse (après l'utilisation d'un outil), SessionStart (au démarrage d'une session) ou UserPromptSubmit (lors de la soumission d'un prompt).7 Ils sont configurés dans le fichier settings.json et peuvent être utilisés pour faire respecter des standards, valider les entrées des outils ou automatiser des actions de suivi.11 Par exemple, un hook PreToolUse peut intercepter une commande Bash pour bloquer des opérations dangereuses comme rm \-rf 12, tandis qu'un hook PostToolUse sur l'outil Write peut automatiquement lancer un linter ou un formateur de code.11  
Les hooks sont le fondement de l'automatisation *déterministe* et *obligatoire*. Contrairement aux commandes slash, ce ne sont pas des raccourcis optionnels ; ce sont des garde-fous et des améliorations de processus intégrés. Ils sont particulièrement adaptés aux tâches qui doivent être exécutées de manière cohérente sans intervention de l'utilisateur pour maintenir la qualité du code, la sécurité ou la consistance de l'environnement. Leur puissance réside dans leur capacité à intercepter et à modifier le flux de travail de l'agent, ce qui les rend essentiels pour mettre en œuvre des politiques de sécurité et des standards de développement robustes au sein d'une équipe.4

### **2.3 Gérer la Complexité et le Contexte avec les Sous-Agents**

Les sous-agents sont des assistants IA spécialisés, chacun doté de son propre prompt système, de permissions d'outils spécifiques et d'une fenêtre de contexte isolée.1 L'agent principal peut leur déléguer des tâches complexes ou gourmandes en tokens.5 Cette approche est idéale pour des missions telles que la recherche approfondie, l'analyse de fichiers journaux volumineux ou la réalisation d'un audit de sécurité, où les étapes intermédiaires pollueraient autrement le contexte de la conversation principale.1 Les sous-agents peuvent être configurés pour utiliser l'outil Bash, avec un accès restreint via le champ tools dans leur fichier de définition Markdown.5  
Le principe de conception fondamental des sous-agents est la *délégation et la synthèse*. Au lieu que l'agent principal effectue une tâche verbeuse et coûteuse en tokens, comme analyser un fichier journal massif avec grep et awk, il peut déléguer cette tâche à un sous-agent spécialisé, par exemple un log-analyzer. Le sous-agent effectue le travail dans son contexte isolé et ne renvoie que le résultat final et synthétisé à l'agent principal. Ce faisant, il préserve un contexte précieux dans le fil de raisonnement principal, ce qui est crucial pour faire évoluer les workflows agentiques vers la résolution de problèmes non triviaux.1

### **Tableau 2.1 : Matrice de Sélection des Composants d'Automatisation**

Ce tableau fournit un guide de référence rapide pour aider les développeurs à choisir le composant architectural le plus adapté à leurs besoins d'automatisation.

| Caractéristique | Commandes Slash Personnalisées | Hooks | Sous-Agents |
| :---- | :---- | :---- | :---- |
| **Déclencheur d'Invocation** | Manuel (initié par l'utilisateur via /command) | Automatique (piloté par des événements, ex. PreToolUse) | Automatique (délégué par l'IA) ou Manuel (dirigé par l'utilisateur) |
| **Portée du Contexte** | Partagé (opère dans la conversation principale) | N/A (s'exécute en externe, peut fournir un retour au contexte) | Isolé (fenêtre de contexte séparée) |
| **Cas d'Usage Principal** | Raccourcis réutilisables, encapsulation de workflows | Application de politiques, validation, automatisation de processus | Délégation de tâches complexes, mitigation de la pollution de contexte |
| **Accès aux Scripts Shell** | Préfixe \! dans le Markdown, sortie injectée dans le prompt | Champ command dans settings.json | Permission de l'outil Bash accordée dans la définition de l'agent |
| **Bénéfice Clé** | Productivité et commodité | Cohérence et sécurité | Évolutivité et concentration |

Ces composants ne sont pas simplement une collection d'outils, mais forment une architecture de contrôle en couches. Les **hooks** constituent la couche de base, un ensemble de règles non négociables qui garantissent la sécurité et les standards. Les **sous-agents** sont la couche intermédiaire, des unités fonctionnelles spécialisées qui gèrent des sous-problèmes complexes, à la manière d'une architecture de microservices. Enfin, les **commandes slash** représentent la couche supérieure, une interface utilisateur pour initier des workflows courants. Cette vision en couches offre un modèle mental pour concevoir des systèmes agentiques sophistiqués. De plus, l'introduction de l'outil SlashCommand permet à l'agent lui-même d'invoquer ces commandes, les transformant de simples raccourcis en une API interne de haut niveau, favorisant une automatisation plus robuste et abstraite.10  
---

## **Section 3 : Meilleures Pratiques pour la Rédaction de Scripts Shell Consommables par l'IA**

Cette section synthétise les meilleures pratiques traditionnelles du scripting shell avec les exigences uniques d'un consommateur IA, établissant un ensemble de principes pour écrire des scripts robustes, prévisibles et efficaces dans un contexte automatisé.

### **3.1 Robustesse et Lisibilité Fondamentales (Le Google Shell Style Guide)**

Le Google Shell Style Guide est recommandé comme une norme fondamentale pour la rédaction de scripts.16 Ses principes clés incluent l'utilisation de Bash (\#\!/bin/bash) comme standard, une indentation de 2 espaces, des lignes de moins de 80 caractères, la redirection des erreurs vers STDERR, le guillemet systématique des variables ("${var}"), et la rédaction de commentaires clairs dans les en-têtes de fichiers et de fonctions.17 Il est également conseillé de réécrire dans un langage plus structuré tout script dépassant 100 lignes.17  
Le respect d'un guide de style strict est encore plus crucial pour une IA que pour un humain. Un agent IA ne possède pas la capacité intuitive de déchiffrer un code mal formaté ou ambigu. Un formatage cohérent, des noms de variables clairs et des commentaires exhaustifs ne sont pas seulement des aides à la maintenance ; ce sont des entrées directes qui aident l'agent à comprendre le but et le fonctionnement du script, ce qui conduit à une exécution et une itération plus fiables.18

### **3.2 L'Impératif de l'Idempotence**

Un script idempotent est un script qui, exécuté plusieurs fois, produit le même résultat que s'il n'avait été exécuté qu'une seule fois.19 Cette propriété est cruciale pour l'automatisation par l'IA, où un agent pourrait décider de ré-exécuter un script d'installation ou de déploiement. Les motifs de conception pour atteindre l'idempotence incluent l'utilisation de mkdir \-p au lieu de mkdir, ln \-sf pour les liens symboliques, rm \-f pour éviter les erreurs sur les fichiers non existants, et l'utilisation de grep \-q pour vérifier si une ligne de configuration existe déjà avant de l'ajouter.20  
Dans un workflow agentique, l'IA peut perdre le fil de son état ou décider de ré-exécuter une étape précédente pour vérification. Les scripts non idempotents sont une source majeure d'échecs dans ce contexte. Par exemple, un script qui ajoute une ligne à un fichier de configuration sans vérifier son existence créera des entrées en double et cassera le système.21 Intégrer l'idempotence dans chaque script est un principe fondamental de la programmation défensive pour les agents IA. Cela garantit que le système converge vers l'état désiré, quel que soit le nombre de fois que l'agent exécute une commande. Cette approche force un changement de paradigme : au lieu de commandes impératives ("ajoute cette ligne"), on utilise des vérifications d'état déclaratives ("assure-toi que cette ligne existe"). Le motif \`test |  
| action\` 20 est l'incarnation de cette approche, décrivant l'état final souhaité et laissant le script déterminer si une action est nécessaire.

### **3.3 Gestion Avancée des Erreurs pour l'Exécution Agentique**

Un défi majeur réside dans la gestion du code de sortie de commandes comme grep. Cet outil renvoie 0 en cas de correspondance, 1 en l'absence de correspondance, et une valeur supérieure à 1 en cas d'erreur.22 Lorsqu'un script est exécuté avec l'option set \-e (qui provoque la sortie du script à la première erreur), une commande grep qui ne trouve aucune correspondance mettra fin prématurément au script entier.24 L'outil Bash de Claude Code peut mal interpréter ce code de sortie 1 comme une erreur authentique, perturbant ainsi sa boucle de débogage agentique.25  
Pour gérer ce comportement, les scripts doivent contrôler explicitement le code de sortie de grep.

* La solution la plus simple, \`grep... |

| true\`, supprime tous les codes de sortie non nuls, y compris les erreurs réelles, ce qui est souvent trop permissif.24

* Un motif plus robuste est \`grep... |

| \[\[ $? \== 1 \]\]. Cette construction permet au script de continuer uniquement si le code de sortie est 1(pas de correspondance), mais échouera correctement en cas d'erreur réelle (code de sortie\>1\`).26  
Ce cas spécifique de grep est emblématique d'une classe plus large de problèmes lorsque des outils hérités rencontrent des systèmes agentiques modernes. L'interprétation du succès et de l'échec par l'IA est littérale. Les scripts doivent être écrits pour s'aligner sur cette interprétation. Le motif || \[\[ $? \== 1 \]\] est une micro-architecture essentielle qui rend les scripts résilients et compatibles avec l'IA, garantissant que l'agent reçoit un signal clair sur le résultat d'une opération de recherche. Enfin, le fichier CLAUDE.md peut servir de "méta-script", fournissant une documentation qui guide l'utilisation par l'IA d'autres scripts plus complexes, en listant par exemple les commandes fréquemment utilisées avec leurs descriptions.3  
---

## **Section 4 : Une Approche "Security-First" pour le Scripting Agentique**

Cette section détaille les considérations de sécurité critiques liées à l'octroi d'un accès shell à un agent IA, en fournissant un cadre complet pour atténuer les risques tels que l'exfiltration de données et la modification non autorisée du système.

### **4.1 Mettre en Œuvre le Principe du Moindre Privilège**

Le principe de sécurité fondamental est de n'accorder que les permissions minimales nécessaires.28 Ceci est réalisé grâce au système de permissions granulaires de Claude Code, configurable via \~/.claude.json ou la commande /permissions.28 Le système utilise des règles allow (autoriser), ask (demander) et deny (refuser) qui peuvent correspondre à des motifs de commandes spécifiques.30 Au lieu d'une autorisation globale comme Bash(\*), il est impératif d'utiliser des motifs très spécifiques tels que Bash(git status:\*), Bash(npm install:\*), ou Bash(docker ps:\*).28 La liste deny doit être utilisée de manière agressive pour bloquer l'accès aux fichiers sensibles comme ./.env ou \~/secrets/\*\*, et le mode par défaut devrait toujours être ask.30  
Le modèle mental correct est de traiter l'agent IA comme un "stagiaire puissant mais non fiable".30 Le système de permissions est l'outil principal pour appliquer ce modèle. Une stratégie "tout refuser par défaut" ou "tout demander par défaut" est essentielle. Ce modèle de sécurité reflète celui des infrastructures modernes comme IAM (Identity and Access Management) dans le cloud, où la sécurité n'est pas axée sur la correction de vulnérabilités spécifiques mais sur la définition de politiques d'accès strictes pour les actions et les ressources.

### **4.2 Prévenir l'Exfiltration de Secrets et de Données**

Une menace majeure est la capacité de l'agent à lire des fichiers sensibles (.env, identifiants AWS) et à les exfiltrer.30 Les scripts conçus pour l'agent doivent gérer les secrets de manière sécurisée. Cela implique de nettoyer les sorties pour supprimer les informations d'identification avant qu'elles ne soient renvoyées au contexte de l'agent.6 La pratique recommandée est d'éviter complètement les secrets en clair et d'utiliser des outils externes de gestion des secrets comme Vault.30 Les secrets doivent être transmis sous forme de jetons à courte durée de vie via une injection sécurisée dans l'environnement, et jamais rendus visibles dans un contexte accessible par l'agent.29  
La sécurité doit être intégrée dès la conception des scripts et de l'environnement. Le nettoyage de la sortie des scripts est une dernière ligne de défense cruciale, mais la stratégie la plus robuste consiste à architecturer l'environnement de telle sorte que l'agent n'ait jamais accès à des secrets à longue durée de vie. Cela nécessite une approche de "défense en profondeur" qui combine les contrôles internes de Claude Code avec un sandboxing au niveau du système d'exploitation, comme l'exécution de l'agent entier dans un conteneur Docker ou une machine virtuelle dédiée.30 Si un attaquant parvenait à contourner les permissions internes, il resterait confiné dans un environnement isolé avec un accès limité au système hôte.

### **4.3 Guider les Opérations Sécurisées via CLAUDE.md et les Hooks**

Le fichier CLAUDE.md peut être utilisé pour fournir des instructions de sécurité explicites à l'agent, telles que "Ne jamais commiter de clés d'API dans le dépôt".3 Les hooks offrent un mécanisme d'application encore plus fort et déterministe. Un hook PreToolUse peut être configuré pour analyser les paramètres de toute commande git commit ou git push afin de s'assurer qu'aucun secret n'est inclus.12  
Cette approche combine une orientation "douce" et une application "dure". Le fichier CLAUDE.md éduque l'agent sur les meilleures pratiques, réduisant la probabilité qu'il tente une action dangereuse. Les hooks agissent comme un filet de sécurité, bloquant par programme toute action de ce type qui pourrait passer au travers. Une posture de sécurité complète nécessite les deux.  
---

## **Conclusion**

La maîtrise du scripting shell au sein de Claude Code est fondamentalement un exercice d'architecture de systèmes agentiques. Ce rapport a démontré la relation symbiotique entre des scripts bien conçus—robustes, idempotents, consommables par l'IA et sécurisés—et les capacités fondamentales de l'agent. Des scripts efficaces ne se contentent pas d'exécuter des tâches ; ils fournissent des signaux clairs qui guident le raisonnement et la boucle de débogage de l'IA.  
Les conclusions clés à retenir sont la nécessité d'une mentalité "security-first", l'importance de comprendre les compromis architecturaux entre les commandes slash, les hooks et les sous-agents, et le changement de paradigme vers l'écriture de scripts déclaratifs et conscients de l'état. En combinant des principes d'ingénierie logicielle disciplinés avec une compréhension approfondie du modèle agentique, les développeurs peuvent transformer Claude Code d'un assistant puissant en un véritable partenaire collaboratif, capable d'automatiser des workflows de développement complexes de manière sûre et efficace.

#### **Sources des citations**

1. Building agents with the Claude Agent SDK \- Anthropic, consulté le octobre 22, 2025, [https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk](https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk)  
2. Claude Code Documentation, consulté le octobre 22, 2025, [https://cc.deeptoai.com/docs/en](https://cc.deeptoai.com/docs/en)  
3. Claude Code and Bash Scripts | Developing with AI Tools | Steve ..., consulté le octobre 22, 2025, [https://stevekinney.com/courses/ai-development/claude-code-and-bash-scripts](https://stevekinney.com/courses/ai-development/claude-code-and-bash-scripts)  
4. Customize Claude Code with plugins \- Anthropic, consulté le octobre 22, 2025, [https://www.anthropic.com/news/claude-code-plugins](https://www.anthropic.com/news/claude-code-plugins)  
5. Subagents \- Claude Docs, consulté le octobre 22, 2025, [https://docs.claude.com/en/docs/claude-code/sub-agents](https://docs.claude.com/en/docs/claude-code/sub-agents)  
6. Bash tool \- Claude Docs, consulté le octobre 22, 2025, [https://docs.claude.com/en/docs/agents-and-tools/tool-use/bash-tool](https://docs.claude.com/en/docs/agents-and-tools/tool-use/bash-tool)  
7. Cooking with Claude Code: The Complete Guide \- Sid Bharath, consulté le octobre 22, 2025, [https://www.siddharthbharath.com/claude-code-the-complete-guide/](https://www.siddharthbharath.com/claude-code-the-complete-guide/)  
8. Effective context engineering for AI agents \- Anthropic, consulté le octobre 22, 2025, [https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents](https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents)  
9. \[FEATURE\] Add Interactive Shell Support to the Bash Tool via Pseudo-Terminal (PTY) · Issue \#9881 · anthropics/claude-code \- GitHub, consulté le octobre 22, 2025, [https://github.com/anthropics/claude-code/issues/9881](https://github.com/anthropics/claude-code/issues/9881)  
10. Slash commands \- Claude Docs, consulté le octobre 22, 2025, [https://docs.claude.com/en/docs/claude-code/slash-commands](https://docs.claude.com/en/docs/claude-code/slash-commands)  
11. Hooks reference \- Claude Docs, consulté le octobre 22, 2025, [https://docs.claude.com/en/docs/claude-code/hooks](https://docs.claude.com/en/docs/claude-code/hooks)  
12. The Ultimate Claude Code Guide: Every Hidden Trick, Hack, and Power Feature You Need to Know \- DEV Community, consulté le octobre 22, 2025, [https://dev.to/holasoymalva/the-ultimate-claude-code-guide-every-hidden-trick-hack-and-power-feature-you-need-to-know-2l45](https://dev.to/holasoymalva/the-ultimate-claude-code-guide-every-hidden-trick-hack-and-power-feature-you-need-to-know-2l45)  
13. Practical guide to mastering Claude Code's main agent and Sub‑agents, consulté le octobre 22, 2025, [https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00)  
14. Slash Commands vs Subagents: How to Keep AI Tools Focused \- Jason Liu, consulté le octobre 22, 2025, [https://jxnl.co/writing/2025/08/29/context-engineering-slash-commands-subagents/](https://jxnl.co/writing/2025/08/29/context-engineering-slash-commands-subagents/)  
15. Claude Code can invoke your custom slash commands : r/ClaudeAI \- Reddit, consulté le octobre 22, 2025, [https://www.reddit.com/r/ClaudeAI/comments/1noyvmq/claude\_code\_can\_invoke\_your\_custom\_slash\_commands/](https://www.reddit.com/r/ClaudeAI/comments/1noyvmq/claude_code_can_invoke_your_custom_slash_commands/)  
16. 4\. Google Shell Style Guide — IFS Shell Standard documentation \- ECMWF Sites Hub, consulté le octobre 22, 2025, [https://sites.ecmwf.int/docs/ifs-arpege-coding-standards/shell/guidelines/google.html](https://sites.ecmwf.int/docs/ifs-arpege-coding-standards/shell/guidelines/google.html)  
17. styleguide | Style guides for Google-originated open-source projects, consulté le octobre 22, 2025, [https://google.github.io/styleguide/shellguide.html](https://google.github.io/styleguide/shellguide.html)  
18. Can you share some tips for writing long bash scripts to automate complex tasks without making them too unmanageable? \- Quora, consulté le octobre 22, 2025, [https://www.quora.com/Can-you-share-some-tips-for-writing-long-bash-scripts-to-automate-complex-tasks-without-making-them-too-unmanageable](https://www.quora.com/Can-you-share-some-tips-for-writing-long-bash-scripts-to-automate-complex-tasks-without-making-them-too-unmanageable)  
19. Make your bash scripts idempotent. \- GitHub, consulté le octobre 22, 2025, [https://github.com/metaist/idempotent-bash](https://github.com/metaist/idempotent-bash)  
20. How to write idempotent Bash scripts · Fatih Arslan \- Reddit, consulté le octobre 22, 2025, [https://www.reddit.com/r/bash/comments/rc9y3k/how\_to\_write\_idempotent\_bash\_scripts\_fatih\_arslan/](https://www.reddit.com/r/bash/comments/rc9y3k/how_to_write_idempotent_bash_scripts_fatih_arslan/)  
21. How to write idempotent Bash scripts \- Fatih Arslan, consulté le octobre 22, 2025, [https://arslan.io/2019/07/03/how-to-write-idempotent-bash-scripts/](https://arslan.io/2019/07/03/how-to-write-idempotent-bash-scripts/)  
22. The return code from 'grep' is not as expected on Linux \- Stack Overflow, consulté le octobre 22, 2025, [https://stackoverflow.com/questions/42251386/the-return-code-from-grep-is-not-as-expected-on-linux](https://stackoverflow.com/questions/42251386/the-return-code-from-grep-is-not-as-expected-on-linux)  
23. Do Shell Script Grep Action Fails When Script Returns Nothing \- Keyboard Maestro Forum, consulté le octobre 22, 2025, [https://forum.keyboardmaestro.com/t/do-shell-script-grep-action-fails-when-script-returns-nothing/21130](https://forum.keyboardmaestro.com/t/do-shell-script-grep-action-fails-when-script-returns-nothing/21130)  
24. \`set \-e\` and \`grep\` idiom for preventing premature exit from shell script when pattern not found \- Unix & Linux Stack Exchange, consulté le octobre 22, 2025, [https://unix.stackexchange.com/questions/235017/set-e-and-grep-idiom-for-preventing-premature-exit-from-shell-script-when-p](https://unix.stackexchange.com/questions/235017/set-e-and-grep-idiom-for-preventing-premature-exit-from-shell-script-when-p)  
25. \[BUG\] Bash tool incorrectly reports "Error" for normal non-zero exit codes \#6039 \- GitHub, consulté le octobre 22, 2025, [https://github.com/anthropics/claude-code/issues/6039](https://github.com/anthropics/claude-code/issues/6039)  
26. Preventing grep from causing premature termination of "bash \-e" script, consulté le octobre 22, 2025, [https://unix.stackexchange.com/questions/330660/preventing-grep-from-causing-premature-termination-of-bash-e-script](https://unix.stackexchange.com/questions/330660/preventing-grep-from-causing-premature-termination-of-bash-e-script)  
27. Anthropic Claude Code CLI: Prompts & Tool Definitions \- AI Engineer Guide, consulté le octobre 22, 2025, [https://aiengineerguide.com/blog/claude-code-prompt/](https://aiengineerguide.com/blog/claude-code-prompt/)  
28. What is Bash Mode in Claude Code | ClaudeLog, consulté le octobre 22, 2025, [https://www.claudelog.com/faqs/what-is-bash-mode/](https://www.claudelog.com/faqs/what-is-bash-mode/)  
29. Mastering Claude Agent SDK: Best Practices for Developing AI Agents (2025) \- Skywork.ai, consulté le octobre 22, 2025, [https://skywork.ai/blog/claude-agent-sdk-best-practices-ai-agents-2025/](https://skywork.ai/blog/claude-agent-sdk-best-practices-ai-agents-2025/)  
30. Claude Code Security Best Practices \- Backslash, consulté le octobre 22, 2025, [https://www.backslash.security/blog/claude-code-security-best-practices](https://www.backslash.security/blog/claude-code-security-best-practices)  
31. Claude Code: Best practices for agentic coding \- Anthropic, consulté le octobre 22, 2025, [https://www.anthropic.com/engineering/claude-code-best-practices](https://www.anthropic.com/engineering/claude-code-best-practices)